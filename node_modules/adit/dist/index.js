'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _path = require('path');

var path = _interopRequireWildcard(_path);

var _fs = require('fs');

var _net = require('net');

var net = _interopRequireWildcard(_net);

var _events = require('events');

var _ssh = require('ssh2');

var _ssh2 = _interopRequireDefault(_ssh);

var _vow = require('vow');

var vow = _interopRequireWildcard(_vow);

var _sshUrl = require('ssh-url');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defer = (0, _symbol2.default)();
var inDefer = (0, _symbol2.default)();
var outDefer = (0, _symbol2.default)();
var retryTimes = (0, _symbol2.default)();
var tryMethod = (0, _symbol2.default)();

var Adit = function () {
  (0, _createClass3.default)(Adit, null, [{
    key: 'getPort',


    /**
     * Return default port or passed port or get port within the range
     * @static
     * @param {Number | Array} port
     * @return {Number}
     */


    /**
     * @static
     * @type {Connection}
     */
    value: function getPort(port) {
      if (Array.isArray(port)) {
        return Adit.getRandom(port[0], port[1]);
      }

      return port;
    }

    /**
     * Get random number
     * @static
     * @param {Number} min
     * @param {Number} max
     * @return {Number}
     */


    /**
     * @static
     * @type {Function}
     */


    /**
     * @private
     * @type {Net}
     */

  }, {
    key: 'getRandom',
    value: function getRandom(min, max) {
      return Math.floor(Math.random() * (max - min)) + min;
    }

    /**
     * Simplify port set
     * @static
     * @param {Object} from
     * @param {Object} to
     * @return {Object}
     */

  }, {
    key: 'getAddresses',
    value: function getAddresses(from, to) {
      from = {
        host: from.host || 'localhost',
        port: Adit.getPort(from.port)
      };
      to = {
        host: to.host || 'localhost',
        port: Adit.getPort(to.port)
      };

      return { from: from, to: to };
    }
  }, {
    key: 'parse',
    value: function parse(string, password) {
      var _string$split = string.split(' '),
          _string$split2 = (0, _slicedToArray3.default)(_string$split, 2),
          auth = _string$split2[0],
          url = _string$split2[1];

      // Like 9000:example.com:80


      auth = auth.split(':');
      url = (0, _sshUrl.parse)(url);

      return {
        host: url.hostname,
        port: url.port || 22,
        username: url.user,
        password: password || null,

        from: {
          host: 'localhost',
          port: auth[0]
        },

        to: {
          host: auth[1],
          port: auth[2]
        }
      };
    }

    /**
     * @constructor
     * @param {Object | String} settings
     * @param {String} [password]
     * @param {String} settings.host
     * @param {String} [settings.username]
     * @param {Number | Array} [settings.port] - number or range
     * @param {String} [settings.password]
     * @param {String} [settings.agent]
     * @param {String} [settings.key]
     * @return {Adit}
     */

  }]);

  function Adit(settings, password) {
    (0, _classCallCheck3.default)(this, Adit);

    if (typeof settings === 'string') {
      settings = Adit.parse(settings, password);
    }

    /**
     * Host name/address
     * @type {String}
     */
    this.host = settings.host;

    /**
     * Original port range, needed if we infact received port range,
     * so we could extract new port for new connection
     * @type {Number | Array}
     */
    this.portRange = settings.port || 22;

    /**
     * Currently used port
     * @type {Number}
     */
    this.port = Adit.getPort(this.portRange);

    /**
     * Username of the remote host
     * @type {String}
     */
    this.username = settings.username || process.env.USER || null;

    /**
     * User password
     * @type {String | null}
     */
    this.password = settings.password || null;

    /**
     * Path to ssh-agent socket
     * @type {String | null}
     */
    this.agent = settings.agent || process.env.SSH_AUTH_SOCK || null;

    /**
     * Authorization key
     * @type {Buffer | null}
     */
    this.key = null;

    /**
     * "From" forward settings
     * @type {Object | null}
     */
    this.from = settings.from || null;

    /**
     * "To" forward settings
     * @type {Object | null}
     */
    this.to = settings.to || null;

    /**
     * How many times should we try to reconnect?
     * @private
     * @type {Number}
     */
    this[retryTimes] = 0;

    /**
    * Deferred object which we will resolve when connect to the remote host
    * @private
    * @type {Object}
    */
    this[defer] = vow.defer();

    /**
     * Deferred object which we will resolve when forwarding to *remote* host is established
     * @private
     * @type {Object}
     */
    this[inDefer] = vow.defer();

    /**
     * Deferred object which we will resolve when forwarding to *local* host is established
     * @private
     * @type {Object}
     */
    this[outDefer] = vow.defer();

    /**
     * Promise object which will be resolved when connect to the remote host
     * @type {Object}
     */
    this.promise = this[defer].promise();

    /**
     * Our ssh connection
     * @type {Connection}
     */
    this.connection = new Adit.Connection();

    /**
     * Event emitter
     * @type {EventEmitter}
     */
    this.events = new _events.EventEmitter();

    /**
     * Store all streams, so we could clean up event loop queue
     * @type {Array}
     */
    this.streams = [];

    /**
     * Event listener
     * @type {Function}
     */
    this.on = this.events.on.bind(this.events);

    // Authentification strategy
    // If password is defined - use it
    // If agent or key is defined explicitly - use one of them, prioritize the agent
    // If agent or key is not passed - use environment varible if deinfed, prioritize the agent
    // Note: if key is used, assume it is added without passphrase, otherwise you should use agent
    if (this.password) {
      this.key = this.agent = null;
    } else if (!settings.agent && !settings.password && settings.key) {
      this.key = Adit.read(settings.key);
      this.agent = null;
    } else if (!this.agent && !this.password && process.env.HOME) {
      this.key = Adit.read(path.join(process.env.HOME, '.ssh', 'id_rsa'));
    }

    if (!this.password && !this.agent && !this.key) {
      throw new Error('SSH-agent is not enabled, private key doesn\'t exist \n' + 'and password is not provided we need at least one of those things');
    }
  }

  /**
   * Do the Adit#addEvents and Adit#connect
   * @see Adit#connect
   */


  (0, _createClass3.default)(Adit, [{
    key: 'open',
    value: function open() {
      var retries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this.addEvents();
      this.connect(retries);
      return this.promise;
    }

    /**
     * Connect to the remote server
     * @param {Number} [retries = 0] - how many times can we try to connect
     */

  }, {
    key: 'connect',
    value: function connect() {
      var retries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this[retryTimes] = retries;

      var settings = {
        host: this.host,
        port: this.port,
        username: this.username
      };

      if (this.password) {
        settings.password = this.password;
      } else if (this.agent) {
        settings.agent = this.agent;
      } else {
        settings.privateKey = this.key;
      }

      this.connection.connect(settings);
    }

    /**
     * Close connection to the remote server
     */

  }, {
    key: 'close',
    value: function close() {
      this.connection.end();
    }

    /**
    * Helper for the Adit#reTry
    * @private
    */

  }, {
    key: tryMethod,
    value: function value() {
      // Close current connection
      this.close();

      // Try new port
      this.port = Adit.getPort(this.portRange);

      // Recreate the connection
      this.connection = new Adit.Connection();

      // Shot decrement
      this.open(this[retryTimes] - 1);
    }

    /**
     * Try to reconnect to the remote host (has side effect)
     * @param {*} error - error that will be thrown if we don't want to try anymore
     */

  }, {
    key: 'reTry',
    value: function reTry(error) {
      if (this[retryTimes] !== 0) {
        this[tryMethod]();
      } else {
        this[defer].reject(error);
      }
    }

    /**
     * Forward all connections
     * @return {Promise}
     */

  }, {
    key: 'forward',
    value: function forward() {
      var _this = this;

      return this.open().then(function () {
        return _this.out(_this.from, _this.to);
      });
    }

    /**
     * Get all connections from remote
     * @return {Promise}
     */

  }, {
    key: 'reverse',
    value: function reverse() {
      var _this2 = this;

      return this.open().then(function () {
        return _this2.in(_this2.to, _this2.from);
      });
    }

    /**
     * Forward requests from remote server to your local one
     * @param {Object} from
     * @param {Object} to
     * @return {Promise}
     */

  }, {
    key: 'in',
    value: function _in(from, to) {
      var _this3 = this;

      var _Adit$getAddresses = Adit.getAddresses(from, to);

      from = _Adit$getAddresses.from;
      to = _Adit$getAddresses.to;


      this.connection.on('tcp connection', function (info, accept) {
        var stream = accept();

        stream.on('data', _this3.events.emit.bind(_this3.events, 'data'));

        // Connect to the socket and output the stream
        var socket = Adit.net.connect(to.port, to.host, function () {
          stream.pipe(socket);
          socket.pipe(stream);
        });

        _this3.events.emit('tcp connection');

        // Store all streams, so we can clean it up afterwards
        _this3.streams.push(socket, stream);
      });

      this.connection.forwardIn(from.host, from.port, function (error) {
        if (error) {
          _this3.events.emit('error', error);
          _this3[inDefer].reject(error);
        } else {
          _this3[inDefer].resolve(_this3);
        }
      });

      return this[inDefer].promise();
    }

    /**
     * Forward requests from local server to remote one
     * @param {Object} from
     * @param {Object} to
     * @return {Promise}
     */

  }, {
    key: 'out',
    value: function out(from, to) {
      var _this4 = this;

      // Since for `forwardOut` creates only one connection, we would have to create a
      // server to pipe all requests
      var _Adit$getAddresses2 = Adit.getAddresses(from, to);

      from = _Adit$getAddresses2.from;
      to = _Adit$getAddresses2.to;
      Adit.net.createServer(function (socket) {
        _this4.connection.forwardOut(from.host, from.port, to.host, to.port, function (error, stream) {
          // If error reject out promise connection and propogate the error
          if (error) {
            _this4.events.emit('error', error);
            return;
          }

          stream.on('data', _this4.events.emit.bind(_this4.events, 'data'));

          // Pipe requests
          socket.pipe(stream);
          stream.pipe(socket);

          // Store all streams, so we can clean it up afterwards
          _this4.streams.push(socket, stream);
        });
      }).listen(from.port, from.host, function () {
        // Resolve the connection
        _this4[outDefer].resolve(_this4);
      });

      return this[outDefer].promise();
    }

    /**
     * Attach common events and deal with them
     */

  }, {
    key: 'addEvents',
    value: function addEvents() {
      var _this5 = this;

      // Wait for remote connection
      this.connection.on('ready', function () {
        _this5[defer].resolve(_this5);
      });

      this.connection.on('error', function (error) {
        _this5.events.emit('error', error);
        _this5.reTry();
      });

      this.connection.on('close', function (error) {
        // End all streams, to clean up event loop queue
        _this5.streams.forEach(function (stream) {
          return stream.end();
        });
        _this5.events.emit('close', error);
      });
    }
  }]);
  return Adit;
}();

Adit.net = net;
Adit.Connection = _ssh2.default;
Adit.read = _fs.readFileSync;
exports.default = Adit;
module.exports = exports['default'];